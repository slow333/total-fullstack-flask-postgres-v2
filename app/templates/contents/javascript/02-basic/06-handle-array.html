{% extends 'base.html' %}

{% block title %} JavaScript {% endblock %}

{% block header %} Array {% endblock %}

{% block content %}
  <section>
    <h2>push, pop, shift, unshift</h2>
    <h3>arr.shift(); 맴앞에 것을 삭제하고 나머지를 반환</h3>
    <h3>arr.unshift(value); value를 앞에 삽입</h3>
    <h3>참조 복사하면(arr = copied) 두개가 다 같이 변경됨, 참조만 복사항</h3>
    <h3>for...of; 값을 반환해주는 반복문</h3>
  </section>
  <section>
    <h2>Array.isArray</h2>
    <h3>typeof {}; typeof []; // 둘다 객체임</h3>
    <h3>Array.isArray({}); false, Array.isArray([]); true</h3>
  </section>
  <section>
    <h2>thisArg</h2>
    <pre>let army = {
  minAge: 18,  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};
let users = [  {age: 16},  {age: 20},  {age: 23},  {age: 30} ];
// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);
alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23</pre>
  </section>
  <section>
    <h2>arr.map(fn); 함수 호출 결과를 배열로 반환해줌</h2>
    <pre>let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값을 반환합니다.
});</pre>
    <pre>let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6</pre>
    <h2>arr.sort(fn), arr.reverse(fn)</h2>
    <pre>numbersArray.sort((a, b) => a - b);</pre>
    <pre>countriesArray.sort((a,b) => a.localeCompare(b));</pre>
  </section>
  <section>
    <h2>split, join</h2>
    <pre>let names = 'Bilbo, Gandalf, Nazgul';
let arr = names.split(', ');
for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
}
let str = "test";
alert( str.split('') ); // t,e,s,t    </pre>
    <pre>let arr = ['Bilbo', 'Gandalf', 'Nazgul'];
let str = arr.join(';'); // 배열 요소 모두를 ;를 사용해 하나의 문자열로 합칩니다.
alert( str ); // Bilbo;Gandalf;Nazgul</pre>
  </section>
  <section>
    <h2>reduce, reduceRight</h2>
    <h3>reduce와 reduceRight는 배열을 기반으로 값 하나를 도출할 때 사용됩니다.</h3>
    <pre>let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);</pre>
    <pre>let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15</pre>
  </section>
  <section>
    <h2>arr.splice(index[,deleteCount, 추가1, 추가2,...]); //원본 변경</h2>
    <h3>delete arr[1]; //인덱스1을 삭제하지만 크기(length)는 유지됨</h3>
    <pre>  arr.splice(1,2); 인덱스 1부터 2개을 제거
  arr.splic(1,2,"one","two");인덱스 1부터 2개을 제거하고 one, two를 추가
  arr.splic(1,0,"one","two");인덱스 1위치에 one, two를 추가</pre>
  </section>
  <section>
    <h2>arr.slice([start], [end]); 복사한 새로운 배열을 반환</h2>
    <pre>let arr = ["t", "e", "s", "t"];
  arr.slice(1, 3); // e,s (인덱스가 1인 요소부터 인덱스가 3인 요소까지를 복사(인덱스가 3인 요소는 제외))
  arr.slice(-2); // s,t (인덱스가 -2인 요소부터 제일 끝 요소까지를 복사) </pre>
  </section>
  <section>
    <h2>arr.concat(arg1, arg2, ...); 새로운 배열을 반환</h2>
    <pre>let arr = [1, 2];
// arr의 요소 모두와 [3,4]의 요소 모두를 한데 모은 <em>새로운 배열</em>이 만들어집니다.
arr.concat([3, 4]); // 1,2,3,4
// arr의 요소 모두와 [3,4]의 요소 모두, [5,6]의 요소 모두를 모은 새로운 배열이 만들어집니다.
arr.concat([3, 4], [5, 6]); // 1,2,3,4,5,6
// arr의 요소 모두와 [3,4]의 요소 모두, 5와 6을 한데 모은 새로운 배열이 만들어집니다.
arr.concat([3, 4], 5, 6); // 1,2,3,4,5,6</pre>
  </section>
  <section>
    <h2>indexOf(value), lastIndexOf(value); value의 index값을 반환 includes</h2>
    <h2>includes(value); value 포함 여부, true/false</h2>
  </section>
  <section>
    <h2>객체를 이루어진 배열에서 검색: arr.find(fn), arr.findIndex(fn)</h2>
    <pre>let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환합니다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환합니다.
});</pre>
   <pre>let users = [ {id: 1, name: "John"}, {id: 2, name: "Pete"}, {id: 3, name: "Mary"} ];
let user = users.find(item => item.id == 1);
alert(user.name); // John</pre>
    <h2>조건에 맞는 것 모두 찾기: arr.filter(fn)</h2>
    <pre>let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소는 results에 순차적으로 더해집니다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환됩니다.
});</pre>
    <pre>let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2</pre>
  </section>
  <section>
    <h2>ex Calculator</h2>
    <pre>function Calculator() {
  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };
  this.calculate = function(str) {
    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2];
    if (!this.methods[op] || isNaN(a) || isNaN(b)) { return NaN; }
    return this.methods[op](a, b);
  };

  this.addMethod = function(name, func) { this.methods[name] = func; };
}</pre>
    <h3>객체를 반환하기...; () 사용 필요</h3>
    <pre>let usersMapped = users.map(user => {
  fullName: `${user.name} ${user.surname}`,
  id: user.id
});</pre>
    <h4>중괄호 {를 만나면 자바스크립트는 이를 객체의 시작이라 인식하지 않고 함수 본문이 시작되는 것이라 인식합니다. 소괄호를 사용하면 이를 피할 수 있습니다.</h4>
    <pre>let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));</pre>
    <h3>중복 내용 찾아서 없에기</h3>
    <pre>function unique(arr) {
  let result = [];
  for (let str of arr) {
    if (!result.includes(str)) { result.push(str);  }
  }
  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna", "Krishna", "Krishna", "Hare", "Hare", ":-O"];
alert( unique(strings) ); // Hare, Krishna, :-O</pre>
  </section>
{% endblock %}