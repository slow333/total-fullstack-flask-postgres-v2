{% extends 'base.html' %}

{% block title %} Python {% endblock %}
{% block header %} Closer, decorator {% endblock %}
  
{% block content %}
<section>
<h3>closer</h3>
<h5>함수 내부에 함수를 정의하고, 내부에 정의된 함수를 return 하는 함수</h5>
<pre># wrapper.py
def mul(m):
  def wrapper(n):
    return m * n
  return wrapper

if __name__ == "__main__":
  mul3 = mul(3)(10)
  mul5 = mul(5)(10)
  print(mul3)  # 30
  print(mul5)  # 50</pre>
<h3>decorator</h3>
<pre>import time

def elapsed(original_func):   # 기존 함수를 인수로 받는다.
    def wrapper(*args, **kwargs):   # *args, **kwargs 매개변수 추가
        start = time.time()
        result = original_func(*args, **kwargs)  # 전달받은 *args, **kwargs를 입력파라미터로 기존함수 수행
        end = time.time()
        print("함수 수행시간: %f 초" % (end - start))  # 수행시간을 출력한다.
        return result  # 함수의 결과를 리턴한다.
    return wrapper

@elapsed
def myfunc(msg):
    """ 데코레이터 확인 함수 """
    print("'%s'을 출력합니다." % msg)

myfunc("You need python")</pre>
<h3>iterator</h3>
<p>이터레이터는 next 함수 호출 시 계속 그다음 값을 리턴하는 객체<br />
list는 반복가능하나 이터레이터는 아님</p>
<pre>a = [1, 2, 3]  
ia = iter(a)  
next(ia)  
1  
next(ia)  
2  
next(ia)  
3  
next(ia)  
Traceback (most recent call last):  
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;  
StopIteration  </pre>
<h5>iterator class</h5>
<pre>class MyIterator:
    def __init__(self, data):
        self.data = data
        self.position = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.position &gt;= len(self.data):
            raise StopIteration
        result = self.data[self.position]
        self.position += 1
        return result

if __name__ == "__main__":
    i = MyIterator([1,2,3])
    for item in i:
        print(item)</pre>
<h5>generator</h5>
<p>제너레이터(generator)는 이터레이터를 생성해 주는 함수</p>
<pre>def mygen():
  for i in range(1, 1000):
    result = i * i
    yield result

gen = mygen()

print(next(gen))
print(next(gen))
print(next(gen))</pre>
</section>

{% endblock %}