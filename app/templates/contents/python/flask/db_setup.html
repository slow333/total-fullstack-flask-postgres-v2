{% extends 'base.html' %}

{% block title %} Flask {% endblock %}
{% block header %} psycopg2를 통한 db 연결 {% endblock %}
  
{% block content %}
<section> 
  <pre>
import os
import psycopg2
import psycopg2.extras

from flask import g

# os evn에서 가져오기
# window에서는 환경 변수에 추가
# linux에서는 => /etc/profile에 추가 또는 ~/.bashrc에 추가
  export DATABASE=postgresql://postgres:1234@192.168.219.101:5432/mydb
# 아니면 여기에 변수를 생성해서 주입해야함

MY_DB = os.environ.get('MY_DB')
FLASK_DB = os.environ.get('FLASK_DB')

# db 2개를 생성해서 사용(이럴 일이 있나 싶내요)
def get_mydb():
  """Get a database connection from the application context."""
  if 'mydb' not in g:
    g.mydb = psycopg2.connect(MY_DB, cursor_factory=psycopg2.extras.DictCursor)
  if 'flask_db' not in g:
    g.flask_db = psycopg2.connect(flask_db, cursor_factory=psycopg2.extras.DictCursor)
  return g.mydb, g.flask_db

def close_db(e=None):
  """Close the database connection."""
  mydb = g.pop('mydb', None)
  if mydb is not None:
    mydb.close()

  flask_db = g.pop('flask_db', None)
  if flask_db is not None:
    flask_db.close()

def init_app(app):
  """Register database functions with the Flask app."""
  app.teardown_appcontext(close_db)
</pre>
</section>

<section>
  <h2>DB Setup(postgresql): SqlAlchemy Core 방식(ORM 방식 아님)</h2>
  <h3>DB 연결 및 테이블 생성, 주입 : sqlalchemy 1.3.2 기준</h3>
  <pre>from sqlalchemy import create_engine, MetaData
from sqlalchemy import Table, Column, String, insert, Integer, ForeignKey

engine = create_engine('postgresql://postgres:1234@192.168.219.101:5432/mydb', echo=True)
metadata = MetaData()

# create table
users = Table('users', metadata,
  Column('id', Integer, primary_key=True),
  Column('name', String(30)),
  Column('fullname', String(50))
)
addresses = Table('addresses', metadata,
  Column('id', Integer, primary_key=True),
  Column('user_id', Integer, ForeignKey('users.id', ondelete='CASCADE')),
  Column('email_address', String(100), nullable=False)
)
metadata.create_all(engine)  </pre>
</section>

<h1>flask session 관리</h1>
<section>
<p>Flask는 웹 애플리케이션에서 사용자별 데이터를 저장하고 관리하기 위해 세션(Session) 기능을 제공합니다. Flask의 세션은 기본적으로 클라이언트의 브라우저에 저장되는 쿠키 기반(cookie-based) 방식입니다.</p>

<h4>세션의 작동 방식</h4>
<ul>
  <li>세션 생성: 사용자가 웹사이트에 접속하면, Flask는 고유한 세션 ID를 가진 세션 객체를 생성합니다.</li>
  <li>데이터 저장: 개발자는 이 세션 객체에 데이터를 딕셔너리처럼 저장할 수 있습니다 (예: session['username'] = 'Alice').</li>
  <li>암호화된 쿠키: Flask는 이 데이터를 서버에 저장하지 않고, 서명된(signed) 쿠키 형태로 사용자에게 보냅니다. 이 쿠키는 SECRET_KEY로 암호화되어 있어 위변조가 불가능합니다.</li>
  <li>다음 요청: 사용자가 다음 요청을 보낼 때, 브라우저는 이 쿠키를 다시 서버로 전송하고, Flask는 이를 복호화하여 세션 데이터를 불러옵니다.</li>
  <li></li>
</ul>

<h4>세션의 작동 방식</h4>
<ul>
  <li>세션 생성: 사용자가 웹사이트에 접속하면, Flask는 고유한 세션 ID를 가진 세션 객체를 생성합니다.</li>
  <li>데이터 저장: 개발자는 이 세션 객체에 데이터를 딕셔너리처럼 저장할 수 있습니다 (예: session['username'] = 'Alice').</li>
  <li>암호화된 쿠키: Flask는 이 데이터를 서버에 저장하지 않고, 서명된(signed) 쿠키 형태로 사용자에게 보냅니다. 이 쿠키는 SECRET_KEY로 암호화되어 있어 위변조가 불가능합니다.</li>
  <li>다음 요청: 사용자가 다음 요청을 보낼 때, 브라우저는 이 쿠키를 다시 서버로 전송하고, Flask는 이를 복호화하여 세션 데이터를 불러옵니다.</li>
  <li></li>
  <li></li>
</ul>

<h4> 세션 사용을 위한 필수 설정: SECRET_KEY</h4>
<p> 세션 데이터를 안전하게 암호화하기 위해서는 반드시 SECRET_KEY를 설정해야 합니다. 이 키는 외부에 노출되지 않도록 안전하게 관리해야 합니다.</p>
<pre>
from flask import Flask

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_super_secret_key_here'</pre>

<h4>세션 사용 예제</h4>
<p>세션을 사용하려면 Flask의 session 객체를 임포트해야 합니다. session은 g 객체처럼 현재 요청의 컨텍스트에 바인딩된 프록시 객체입니다.</p>
<h5>사용자 아이디를 세션에 저장하여 로그인 상태를 유지하는 예시입니다.</h5>
<pre>
from flask import Flask, session, redirect, url_for, request, render_template

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_super_secret_key_here'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        # 로그인 성공 시, 세션에 사용자 정보 저장
        session['username'] = username
        return redirect(url_for('profile'))
    return render_template('login.html')

@app.route('/profile')
def profile():
    # 세션에 'username'이 있는지 확인하여 로그인 여부 체크
    if 'username' in session:
        return f"Hello, {session['username']}!"
    return redirect(url_for('login'))

@app.route('/logout')
def logout():
    # 세션에서 사용자 정보 제거
    session.pop('username', None)
    return redirect(url_for('login'))

if __name__ == '__main__':
    app.run(debug=True)
</pre>
<h4>세션 설정 옵션</h4>
<ul>
  <li>app.config를 통해 세션의 동작을 제어할 수 있습니다.</li>
  <li>SESSION_COOKIE_NAME: 세션 쿠키의 이름 (기본값: 'session')</li>
  <li>SESSION_COOKIE_SECURE: True로 설정하면 HTTPS 연결에서만 쿠키를 전송합니다. 프로덕션 환경에서는 이 설정을 활성화하는 것이 좋습니다.</li>
  <li>PERMANENT_SESSION_LIFETIME: 세션의 유효 기간(초 단위)을 설정합니다. session.permanent = True로 설정해야 적용됩니다. 기본값은 31일입니다.</li>
  <li>SESSION_COOKIE_DOMAIN: 쿠키를 사용할 도메인을 지정합니다.</li>
</ul>
<pre>
app.config['SESSION_COOKIE_SECURE'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = 3600 # 1시간  </pre>
</section>
{% endblock %}