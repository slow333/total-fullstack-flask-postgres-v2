{% extends "base.html" %}
{% block title %} Main Home {% endblock %}
{% block header %} Main Home {% endblock %}

{% block content %}
<section>
  <h2>주요 버전</h2>
  <h3>python version: 13.6</h3>
  <h3>Database : postgresql로 구현(17.5)</h3>
  <pre>
blinker           1.9.0
click             8.3.0
colorama          0.4.6
Flask             3.1.2
Flask-Admin       1.6.1
Flask-Login       0.6.3
Flask-Mail        0.10.0
Flask-SQLAlchemy  3.1.1
greenlet          3.2.4
itsdangerous      2.2.0
Jinja2            3.1.6
MarkupSafe        3.0.3
pillow            11.3.0
pip               25.2
psycopg2-binary   2.9.10
python-dotenv     1.1.1
SQLAlchemy        2.0.43
typing_extensions 4.15.0
Werkzeug          3.1.3
WTForms           3.1.2 # 이버젼으로 해야 애러 안남
  </pre>
</section>
<h2>프로젝트 구조</h2>
<pre>
/project-v2
  /app
    /routes
    /static
    /templates
    __init__.py
    admin.py
    models.py
    routes.py
    extensions.py # app과 blueprint간 순환참조 문제 해결에 필요
run.py
# 환경변수 설정(마치 시스템에 설정한 것과 같은 효과를 가짐)
.env 
# from dotenv import load_dotenv load_dotenv()해서 사용
config.py
.gitignore
requirements.txt
</pre>
<h2>flask-admin error</h2>
<p>flask-admin user crud error "error AttributeError: 'tuple' object has no attribute 'items'" ==> <strong>flask-wtf 버젼을 3.1.2로 해야 애러 안남</strong></p>
<h4>WTForms versions 3.1.0 and newer introduced changes that are not compatible with Flask-Admin 1.6.1, leading to this crash when Flask-Admin tries to render a create or edit view</h4>
<section>
  <h3>__init__.py</h3>
  <p>__init__로 하면 자신이 속한 폴더(app)에 직접 적용됨</p>
  <p>blueprint와 순환 참조를 해결하기 위해 extensions.py에 설정 분리 </p>
<pre>
from flask import Flask
from config import Config
from flask_admin import Admin
from .extensions import db, mail, login_manager

def create_app(config_class=Config):
  app = Flask(__name__)
  
  # 설정 클래스로부터 설정을 로드
  app.config.from_object(config_class)

  # SQLAlchemy 객체를 앱과 연결
  db.init_app(app)
  mail.init_app(app)
  login_manager.init_app(app)

  # Admin 패널 초기화 및 화면 등록
  from .admin import init_admin
  init_admin(app, db)

  # 블루프린트나 다른 라우트를 여기서 등록
  with app.app_context():

    from .models import User
    @login_manager.user_loader
    def load_user(user_id):
      return User.query.get(int(user_id))
    
    # 모든 blueprints를 등록(app/routes/__init__.py)
    from . import routes 
    routes.init_app(app)

    # 데이터베이스 테이블 생성
    db.create_all()

  return app
</pre>
<h3>extensions.py</h3>
<pre>
from flask_sqlalchemy import SQLAlchemy
from flask_mail import Mail
from flask_login import LoginManager

# SQLAlchemy, Mail, and LoginManager instances
db = SQLAlchemy()
mail = Mail()
login_manager = LoginManager()
login_manager.login_view = 'auth.login_users'
login_manager.login_message_category = 'info'
</pre>
<h3>app/routes/__init__.py</h3>
<pre>
def init_app(app):
    """Register all blueprints for the application."""
    
    # Main application routes
    from . import home
    app.register_blueprint(home.bp)

    # Authentication and user-related routes
    from .auths import auth, user_profile, todo, blog, rest_api_book_bp
    app.register_blueprint(auth.bp)
    app.register_blueprint(user_profile.bp)
    app.register_blueprint(todo.bp)
    app.register_blueprint(blog.bp)
    app.register_blueprint(rest_api_book_bp.bp)

    # Content-specific routes
    from .contents import (
      database_bp, dom_bp, js_bp, home_bp, java_bp, python_bp, spring_bp,
    )
    app.register_blueprint(database_bp.bp)
    app.register_blueprint(dom_bp.bp)
    app.register_blueprint(js_bp.bp)
    app.register_blueprint(home_bp.bp)
    app.register_blueprint(java_bp.bp)
    app.register_blueprint(python_bp.bp)
    app.register_blueprint(spring_bp.bp)

</pre>
<h3>admin.py</h3>
<pre>
from flask import redirect, url_for, flash, Blueprint, render_template
from flask_admin import Admin, AdminIndexView, expose
from flask_login import current_user
from flask_admin.contrib.sqla import ModelView
from wtforms import PasswordField

# Custom Admin Index View to secure the main admin page
class SecureAdminIndexView(AdminIndexView):
  def is_accessible(self):
    # Only grant access if the user is authenticated and is an admin
    return current_user.is_authenticated and current_user.is_admin

  def inaccessible_callback(self, name, **kwargs):
    # Redirect non-admins to the home page or a login page
    flash('You do not have permission to access the admin panel.', 'danger')
    return redirect(url_for('auth.login_users'))

# Custom Model View to secure model management pages
class SecureModelView(ModelView):
  def is_accessible(self):
    # Same security check as the index view
    return current_user.is_authenticated and current_user.is_admin

  def inaccessible_callback(self, name, **kwargs):
    # Redirect non-admins
    flash('You do not have permission to access this resource.', 'danger')
    return redirect(url_for('auth.login_users'))

class UserView(SecureModelView):
  # 이 메서드가 빠지면 `TypeError` 발생 가능성이 높아집니다.
  def __init__(self, model, session, **kwargs):
    # **kwargs를 통해 Flask-Admin의 추가 인자를 모두 받아서  부모 클래스의 생성자에 전달합니다.
    super().__init__(model, session, **kwargs)
  # 폼에 비밀번호 필드 추가
  form_extra_fields = {
    'password': PasswordField('Password')
  }  
  # can_delete = False  can_edit = True  can_create = True
  # can_view_details = True
  # column_exclude_list = ['password_hash', ] 
  # column_searchable_list = ['username', 'email']
  # set password-hash
  def on_model_change(self, form, model, is_created):
    if form.password.data:
      model.set_password(form.password.data)
    elif not is_created:
      del form.password

class BlogView(SecureModelView):
  form_ajax_refs = {
    'author': {
      'fields': ['username', 'email'], # Fields to search against in the User model
      'placeholder': 'Please select a user',
      'page_size': 10,
      'minimum_input_length': 1, # Start searching after typing at least 1 character
    }
  }
class TodoView(SecureModelView):
  form_ajax_refs = {
    'user': {
      'fields': ['username', 'email'], # Fields to search against in the User model
      'placeholder': 'Please select a user',
      'page_size': 10,
      'minimum_input_length': 1, # Start searching after typing at least 1 character
    }
  }
class UserProfileView(SecureModelView):
  # Use AJAX for the 'user' relationship
  # This will render a search box instead of a dropdown
  form_ajax_refs = {
    'user': {
      'fields': ['username', 'email'], # Fields to search against in the User model
      'placeholder': 'Please select a user',
      'page_size': 10,
      'minimum_input_length': 1, # Start searching after typing at least 1 character
    }
  }

class BookView(SecureModelView):
  pass

def init_admin(app, db):
  admin = Admin(
      app,
      name='Admin Panel',
      template_mode='bootstrap4',
      index_view=SecureAdminIndexView(name='Dashboard', url='/admin')
  )

  # Add all specified models to the admin interface
  from .models import User, Blog, Todo, UserProfile, Book
  admin.add_view(UserView(User, db.session, category='Models'))
  admin.add_view(BlogView(Blog, db.session, category='Models'))
  admin.add_view(TodoView(Todo, db.session, category='Models'))
  admin.add_view(UserProfileView(UserProfile, db.session, category='Models'))
  admin.add_view(BookView(Book, db.session, category='Models'))
</pre>
<h3>run.py</h3>
<p>이렇게 별도 구성해야 app에 있는 것을 import 할 수 있음</p>
<pre>
from app import create_app

app = create_app()

if __name__ == '__main__':
  app.run(debug=True)
</pre>
<h3>config.py</h3>
<p>환경 설정 변수를 저장함 : os 환경설정을 대신해서 수행 가능</p>
<p>관련 변수를 .evn에 설정하고 dotenv를 사용(.gitignore에 추가)</p>
<pre>
import os
from dotenv import load_dotenv

# .env 파일에서 환경 변수를 로드합니다.
load_dotenv()

class Config:
  """애플리케이션 환경 설정"""
  # Flask 앱의 보안을 위한 시크릿 키
  SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'

  # 데이터베이스 설정
  SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
  SQLALCHEMY_TRACK_MODIFICATIONS = False

  JSON_AS_ASCII = False  # 한글 깨짐 방지
  # 이메일 설정
  MAIL_SERVER = 'smtp.gmail.com'
  MAIL_PORT = 587
  MAIL_USE_TLS = True
  MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
  MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')  
</pre>
<h3>.evn</h3>
<p>OS에 환경변수로 등록하는 것과 같은 효과를 줌</p>
<pre>
# PostgreSQL 데이터베이스 연결 URI
# 형식: postgresql://사용자이름:비밀번호@호스트:포트/데이터베이스이름
DATABASE_URL="postgresql+psycopg2://postgres:1111@localhost:5432/flask_db"

MAIL_USERNAME = 'xxxx@gmail.com'
MAIL_PASSWORD ='xxxx'
</pre>
<h4>OS에서 환경 설정 : 변수설정은 .env로 대체 가능</h4>
<pre>
set env run script
$ cat ~/.bashrc
alias start="source /b/python/flask-tutorial/.venv/Scripts/activate"
alias run="flask --app flaskr run --debug"
DATABASE_URL="postgresql://postgres:1111@localhost/mydb"
#             db type        id     pass    주소    db이름

# ==== window에서는 ====
고급시스템설정 > 환경변수 > 사용자변수 > 새로만들기
변수이름 : PASSWORD, 변수값: 1111

# flask_crud 
### To run the app, 
### bash: export FLASK_APP=pybo, export FLASK_DEBUG=true , flask run
### cmd : set FLASK_APP=pybo, set FLASK_DEBUG=true, flask run  
</pre>
<h3>models.py</h3>
<pre>
from . import db
from flask_login import UserMixin

# <b>공통으로 사용할 모델</b>
class BaseModel(db.Model):
  __abstract__ = True # 자체에서 테이블을 생성하지 않음
  __allow_unmapped__ = True # 내부에서 db와 상관없는 py객체 생성가능
  id = db.Column(db.Integer, primary_key=True, autoincrement=True)

# <b>UserMixin을 해야 login 상태를 flask_login에서 관리할 수 있음</b>
class User(UserMixin, BaseModel):
  username = db.Column(db.String(64), unique=True, nullable=False)
  email = db.Column(db.String(255), unique=True, nullable=False)
  password = db.Column(db.Text(), nullable=False)

  def __repr__(self):
    return f'{self.username}'
  
class Todo(BaseModel):
  title = db.Column(db.String(100), nullable=False)
  content = db.Column(db.String(200), nullable=False)
  created = db.Column(db.DateTime, default=db.func.current_timestamp())
  completed = db.Column(db.Boolean, default=False)
  # 관계 설정(외래키)
  user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
  # 이걸하면 todo.user.username 처럼 Todo 객체에서 User를 호출 가능
  user = db.relationship('User', backref=db.backref('todos', lazy=True))

  def __repr__(self):
    return f'[Todo {self.id}>'

class Blog(BaseModel):
  title = db.Column(db.String(255), nullable=False)
  content = db.Column(db.Text(), nullable=False)
  comment = db.Column(db.Text(), nullable=True)
  created = db.Column(db.DateTime, default=db.func.current_timestamp())
  author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
  # 이걸하면 blog.author.username 처럼 Todo 객체에서 User를 호출 가능
  author = db.relationship('User', backref=db.backref('blogs', lazy=True))

  def __repr__(self):
    return f'[Blog {self.title} for {self.author.username}>'
  
class UserProfile(BaseModel):
  firstname = db.Column(db.String(60), nullable=True)
  lastname = db.Column(db.String(30), nullable=True)
  address = db.Column(db.String(100), nullable=True)
  profile_image = db.Column(db.String(255), nullable=True)
  user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True, nullable=False)
  user = db.relationship('User', backref=db.backref('profile', uselist=False))

  def __repr__(self):
    return f'[UserProfile for {self.user.username}>'

# flask-admin 관련 
</pre>
</section>
<section>
  <h2>SqlAlchemy ORM</h2>
  <pre>
# Select    
blogs = Blog.query.all()
blogs = db.session.qury(Blog).all()
blog = db.session.qury(Blog).filter(Blog.author_id=1).first()

# Create
db.session.add(Blog(content=content, title=title, author_id=current_user.id))
db.session.commit()

# Update
blog.content = content
db.session.commit()
# Delete
db.session.delete(blog)
db.session.commit()

# Join (using relationship)
# SQLAlchemy automatically knows how to join based on the relationship defined in the model.
# This returns a list of Blog objects where the author's username is 'john'.
blogs_by_john = db.session.query(Blog).join(Blog.author).filter(User.username == 'john').all()

# Join (explicit condition)
# You can also specify the join condition explicitly.
# This returns tuples of (Blog, User) objects.
blogs_with_authors = db.session.query(Blog, User).join(User, Blog.author_id == User.id).all()
for blog, author in blogs_with_authors:
    print(f"Blog: {blog.title}, Author: {author.username}")

# limit, order_by 
profile_page = (
  db.session.query(Profile)
    .order_by(Profile.id.desc())
    .limit(per_page)
    .offset(offset)
    .all()
)
# count
count = db.session.query(Profile).count()

# group_by example
# To count the number of blogs each user has written.
# We need to import `func` from sqlalchemy for aggregate functions like count().
from sqlalchemy import func

user_blog_counts = db.session.query(
    User.username,
    func.count(Blog.id).label('blog_count')
  ).join(Blog, User.id == Blog.author_id).group_by(User.username).all()

# The result will be a list of tuples, e.g., [('john', 5), ('jane', 3)]
for username, count in user_blog_counts:
    print(f"User: {username} has {count} blogs.")
  </pre>
</section>
<section>
  <h3>gmail smtp 사용을 위해서는 myaccount.google.com/apppassowrds 에서 별도로 app 암호를 설저해야함 </h3>
</section>
<section>
  <h2>java 내용 정리</h2>
  <p>Spring boot로 구현</p>
</section>

{% endblock %}